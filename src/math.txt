220802 1. 백준_실버2_1024_수열의 합

규칙을 찾아야하는 수학 문제. 수학문제는 비슷한 유형의 문제를 만나지 않는 이상 내 머리에
맡겨야 한다.

정직하게 수열의 특성을 이용했다.
2       | 3         | 4    <<< k
0+1 = 1 | 0+1+2 = 3 | 0+1+2+3 = 6
1+2 = 3 | 1+2+3 = 6 | 1+2+3+4 = 10
2+3 = 5 | 2+3+4 = 9 | 2+3+4+5 = 15
2n+1    | 3n+3      | 4n+6

=> S(합) = (k * n) + (k * (k - 1) / 2), n을 구하기 위해 변형하면
=> n = (S - (k * (k - 1) / 2)) / k

문제 조건에 따라 k가 100이 넘어가면 -1 리턴
n은 음이 아닌 정수여야 하므로 분자 S - (k * (k - 1) / 2) 가 음이면 -1 리턴하고
또 분자 S - (k * (k - 1) / 2) 가 k로 나누어 떨어져야하며 반복문 돌리면서
조건에 맞는 k가 답의 열쇠다.

```
      function solution(S, k) {
        let answer = [];

        while (true) {
          let tmp = S - (k * (k - 1)) / 2;
          if (tmp < 0) return -1;
          if (k > 100) return -1;
          if (tmp % k === 0) {
            for (let i = tmp / k; i <= tmp / k + k - 1; i++) {
              answer.push(i);
            }
            break;
          }
          k++;
        }

        return answer;
      }
```

220803 1. 백준_실버3_1929_소수 구하기

에라토스테네스의 체 문제. 일단 축하한다. 옛날에 소수 구하는 문제를 접했는데 그때 몰라서
인터넷 봤는데 에라토스테네스 보고도 구현할 줄 몰랐고 이해도 안됬는데 이제는 원리가
떠오르니 바로 구현이 가능할 정도로 되었다. 
암튼 잊지말아야 하는게 시작점을 i * i <= n 범위 설정을 잘 해야한다.
시작점의 제곱이 구하고자 하는 범위를 넘어가면 굳이 연산을 할 필요없다.

그리고 처음에는
for (let i = 2; i <= n; i++) {
          if (check[i]) {
            continue;
          } else {
            if(m <= i && i <= n) answer.push(i)
            for (let j = i; j <= n; j += i) {
              check[j] = i;
            }
          }
        }
이렇게 직접 i를 답에 넣어줬는데 이러면 문제가 제곱을 사용하지 못한다. (물론 100만 까지는 충분)
그래서 밑에 처럼 한번 쭉 순회하고 마지막에 답을 찾아야 한다.

제곱을 쓰면 마지막에 배열을 한번 탐색해야 한다. 하지만 제곱을 쓰지 않는 것 보다 더 빠르다.

```
      function solution(m, n) {
        let answer = [];
        let check = Array.from({ length: n + 1 }, () => 0);

        for (let i = 2; i * i <= n; i++) {
          if (!check[i]) {
            for (let j = i * i; j <= n; j += i) {
              check[j] = i;
            }
          }
        }

        for (let i = m; i <= n; i++) {
          if (!check[i]) answer.push(i);
        }

        return answer;
      }
```