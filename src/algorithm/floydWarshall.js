// 모든 노드 간 최단 거리
// O(V^3) (V은 노드의 개수)

// 이차원 배열을 써야하며 Infinity로 기본값 설정
const graph = Array.from({ length: n + 1 }, () =>
  Array.from({ length: n + 1 }, () => Infinity)
);

const n = 5;

for (let p = 1; p <= n; p++) {
  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= n; j++) {
      graph[i][j] = Math.min(graph[i][j], graph[i][p] + graph[p][j]);
    }
  }
}

// i === j 인 부분은 임의의 노드를 거쳐서 자기 자신 노드에 왔을 때의 최단거리

// ex) 3 에서 2로 가는 최단거리
// 3 -(I)-> 2
// 3 -(1)-> 5 -(3)-> 4 -(4)-> 2
// 3 -(6)-> 4 -(4)-> 2
// 위의 예시에서 값이 p기준 순차적으로 바뀌는 순서를 설명하면 밑처럼 된다
// [i: 3, p: 4, j: 2] (3 -> 4 최단거리 6, 4 -> 2 최단거리 4 ==> 3 -> 2 최단거리 10)
// [i: 5, p: 4, j: 2] (5 -> 2 는 4를 거쳐 최단거리 7로 갱신)
// [i: 3, p: 5: j: 2] (위 5 -> 2 최단거리 7에서 3 -> 5로 가는 최단거리 1 ==> 합해서 3 -> 2 최단거리 8로 갱신)
// 3 -> 2로 가는 최단거리는 8
